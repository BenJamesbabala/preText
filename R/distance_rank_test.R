#' @title Pairwise Document Distance Rank Test
#' @description Document pair distance ranking test metrics.
#'
#' @param distance_matrices A list of document distance matrices.
#' @param choices A dataframe indicating whether a preprocessing step was
#' applied or not, for each preprocessing step.
#' @param labels Optional argument giving names for each preprocessing step.
#' @param method These are different ways of looking for unusual preprocessing
#' steps. If "continuous" is selected, then the average absolute difference in
#' distances between documents is used.
#' @param baseline_index The index of the baseline distance matrix against which
#' we are comparing. Defautls to 128, which is the most minimal preprocessing
#' for our current implementation.
#' @param text_size The cex for text in dot plot generated by function.
#' @param num_comparisons If method = "distribution", the number of ranks to use
#' in calculating average difference. Defautls to 50.
#' @param parallel Logical indicating whether factorial prerpocessing should be
#' performed in parallel. Defualts to FALSE.
#' @param cores Defualts to 1, can be set to any number less than or equal to
#' the number of cores on one's computer.
#' @return A result list object.
#' @export
distance_rank_test <- function(distance_matrices,
                               choices,
                               labels = NULL,
                               method = c("top", "distribution", "continuous"),
                               baseline_index = 128,
                               text_size = 1,
                               num_comparisons = 50,
                               parallel = FALSE,
                               cores = 1){

    method <- method[1]
    num_dms <- length(distance_matrices)

    # figures out which entry in the distance matrix has the largest difference
    # from it to the base case entry.
    get_max_difference <- function (dist_matrix,
                                    baseline) {
        temp <- abs(dist_matrix - baseline)
        temp <- temp[lower.tri(temp)]
        ordering <- order(temp, decreasing = TRUE)
        return(ordering)
    }

    # find out the average rank of this distance difference in all of the other
    # preprocessing steps. Returns the average (absolute) rank difference
    compare_top_difference <- function(distance_matrices,
                                       baseline,
                                       i,
                                       baseline_index,
                                       most_different_index,
                                       place) {
        # create indices to loop through
        inds <- 1:length(distance_matrices)
        inds <- inds[-c(baseline_index, i)]

        rank_of_top_difference <- rep(0,length(inds))
        counter <- 1
        for (j in inds) {

            dist_mat <- distance_matrices[[j]]
            comparison_ordering <- get_max_difference(dist_mat, baseline)
            rank_val <- which(comparison_ordering == most_different_index)
            rank_val <- abs(rank_val - place)
            rank_of_top_difference[counter] <- rank_val
            counter <- counter + 1
        }
        rank_of_top_difference <- rank_of_top_difference/length(lower.tri(dist_mat))
        average_rank <- mean(rank_of_top_difference)

        return(list(ave_diff = average_rank,
                    ave_diff_SE = sd(rank_of_top_difference)))
    }


    baseline <- distance_matrices[[baseline_index]]
    scores <- rep(0,(num_dms - 1))
    score_SE <- rep(0,(num_dms - 1))
    score_counter <- 1
    if (method == "top") {
        # populate the scores vector
        for(i in 1:num_dms) {
            cat("Currently working on DFM:",i,"of",num_dms,"\n")
            # if we are not dealing with the baseline
            if (i != baseline_index) {
                dist_matrix <- distance_matrices[[i]]
                ordering <- get_max_difference(dist_matrix,
                                               baseline)
                most_different_index <- ordering[1]
                result <- compare_top_difference(distance_matrices,
                                                   baseline,
                                                   i,
                                                   baseline_index,
                                                   most_different_index,
                                                   place = 1)
                scores[score_counter] <- result$ave_diff
                score_SE[score_counter] <- result$ave_diff_SE
                score_counter <- score_counter + 1
            }

        }
    } else if (method == "distribution") {
        if (parallel) {
            dfms_to_use <- 1:num_dms
            cat("Preprocessing documents",length(dfms_to_use),
                "different ways on",
                cores,"cores. This may take a while...\n")
            cl <- parallel::makeCluster(getOption("cl.cores", cores))

            dfm_list <- parallel::clusterApplyLB(
                cl = cl,
                x = dfms_to_use,
                fun = parallel_rank_test,
                distance_matrices = distance_matrices,
                baseline = baseline,
                baseline_index = baseline_index,
                num_comparisons = num_comparisons)
            # stop the cluster when we are done
            parallel::stopCluster(cl)

            cat("Paralellization complete!")
            scores <- unlist(dfm_list)
            scores <- scores[-which(scores == 0)]
            print(scores)
        } else {
            # populate the scores vector
            for(i in 1:num_dms) {
                cat("Currently working on DFM:",i,"of",num_dms,"\n")
                ptm <- proc.time()
                # if we are not dealing with the baseline
                if (i != baseline_index) {
                    dist_matrix <- distance_matrices[[i]]
                    ordering <- get_max_difference(dist_matrix,
                                                   baseline)

                    samp <- 1:num_comparisons
                    #samp <- sample(1:length(ordering),num_comparisons)
                    cur_scores <- rep(0,num_comparisons)
                    cur_score_SE <- rep(0,num_comparisons)
                    for (k in 1:num_comparisons) {
                        most_different_index <- ordering[samp[k]]
                        result <- compare_top_difference(distance_matrices,
                                                         baseline,
                                                         i,
                                                         baseline_index,
                                                         most_different_index,
                                                         place = samp[k])
                        cur_scores[k] <- result$ave_diff
                        cur_score_SE[k] <- result$ave_diff_SE
                    }
                    cat("\n")
                    scores[score_counter] <- mean(cur_scores)
                    score_SE[score_counter] <- mean(cur_score_SE)
                    score_counter <- score_counter + 1
                }
                t2 <- proc.time() - ptm
                cat("Complete in:",t2[[3]],"seconds...\n")

            }
        }
    } else if (method == "continuous") {
        stop(paste("method:", method,"is not implemented..."))
    } else {
        stop(paste("method:", method,"is not valid..."))
    }

    labels <- labels[-baseline_index]
    data <- data.frame(Coefficient = scores[order(scores,decreasing = TRUE)],
                       SE = score_SE[order(scores,decreasing = TRUE)],
                       Coefficient_Type = "Difference",
                       Variable = labels[order(scores,decreasing = TRUE)],
                       stringsAsFactors = FALSE)

    data$Variable <- factor(data$Variable,
                            levels = data$Variable[1:nrow(data)])

    UMASS_BLUE <- rgb(51,51,153,195,maxColorValue = 255)
    UMASS_RED <- rgb(153,0,51,195,maxColorValue = 255)

    zp1 <- ggplot2::ggplot(data, ggplot2::aes(colour = Coefficient_Type)) +
        ggplot2::scale_color_manual(values = UMASS_BLUE) +
        ggplot2::theme(axis.text = ggplot2::element_text(size = text_size))

    zp1 <- zp1 + ggplot2::geom_hline(yintercept = 0,
                                     colour = gray(1/2),
                                     lty = 2)
    zp1 <- zp1 + ggplot2::geom_point(ggplot2::aes(x = Variable,
                                                y = Coefficient),
                                     lwd = 1,
                                     shape = 21,
                                     fill = UMASS_BLUE)
    zp1 <- zp1  + ggplot2::theme_bw() +
        ggplot2::coord_flip() +
        ggplot2::theme(legend.position = "none") +
        ggplot2::ylab("Relative Difference") +
        ggplot2::xlab("Preprocessing Combination")

    print(zp1)

    ch <- choices[-baseline_index,]
    choice_diff <- rep(0,ncol(ch))
    pos_sd <- rep(0,ncol(ch))
    neg_sd <- rep(0,ncol(ch))
    for (i in 1:ncol(ch)) {
        pos <- scores[which(ch[,i])]
        neg <- scores[which(!ch[,i])]
        choice_diff[i] <- mean(pos) - mean(neg)
        pos_sd[i] <- sd(pos)
        neg_sd[i] <- sd(neg)
    }

    summary_data <- data.frame(decision = colnames(ch),
                               average_effect = choice_diff,
                               positive_sd = pos_sd,
                               negative_sd = neg_sd,
                               stringsAsFactors = FALSE)

    print(summary_data)

    ret <- data.frame(difference = scores[order(scores,decreasing = TRUE)],
                      preprocessing_steps = labels[order(scores,decreasing = TRUE)],
                      stringsAsFactors = FALSE)

    ret2 <- data.frame(difference = scores,
                      preprocessing_steps = labels,
                      stringsAsFactors = FALSE)

    return(list(dfm_level_results = ret,
                dfm_level_results_unordered = ret2,
                summary_data = summary_data))
}
# for testing
# load("~/Dropbox/Preprocessing_Decisions/Data/Scaling/UK_Manifestos_Scaling_Results.Rdata")
# distance_matrices <- scaling_results$distance_matrices
# load("~/Dropbox/Preprocessing_Decisions/Data/128_Combination_Preprocessing_Labels.Rdata")
# load("~/Dropbox/Preprocessing_Decisions/Data/Scaling/Preprocessing_Choices.Rdata")
